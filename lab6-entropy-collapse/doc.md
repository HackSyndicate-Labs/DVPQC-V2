# Lab 6: Entropy Collapse (Technical Documentation)

## Vulnerability Analysis
The vulnerability is located in `src/Utils/EntropyPool.cpp`.
While the class attempts to gather entropy from system sources (like `/dev/urandom`), it contains a **"Synchronization"** feature intended to stabilize radio frequencies.

```cpp
// src/Utils/EntropyPool.cpp : reseed()

// "Radio Frequency Sync"
uint32_t time_slice = (uint32_t)(time(NULL) / 10); 
uint32_t state = 0xDEADBEEF ^ time_slice;

for (size_t i = 0; i < pool.size(); i++) {
    state = (state * 1103515245 + 12345) & 0x7FFFFFFF;
    pool[i] = (uint8_t)(state >> 16); 
}
```

### The Flaw
The `reseed()` method **overwrites** the entire entropy pool with values generated by a **Linear Congruential Generator (LCG)** seeded with `time(NULL) / 10`.
This effectively makes the "random" number generator:
1.  **Deterministic**: The same seed produces the same sequence.
2.  **Predictable**: The seed is based on the current system time (in 10-second windows).

### Exploitation
An attacker can:
1.  Guess the server's system time (within a small window).
2.  Replicate the LCG algorithm locally (found in `solutions/solve_entropy.py`).
3.  Generate the exact same "random" bytes that the server used to generate its Kyber keys.
4.  Derive the server's private key `sk` and decrypt all messages.

This demonstrates that even with a secure algorithm like Kyber, the **quality of randomness** is the single point of failure.
